# Bit manipulation Coprocessor
  The verification enviroment is setup using Vyoma's UpTick Pro provided for the Hackathon.

  ![verification environment](https://user-images.githubusercontent.com/109404741/180963190-48abe6f0-a586-464b-8dfb-7f43cb05b6dc.PNG)

# Verification environment
  The CoCoTb based python test is explained below. The test drives inputs to the Design Under Test (mkbitmanip module here) which takes in a clock signal,
  3 32 bit inputs marked as mav_putvalue_src1, mav_putvalue_src2 and mav_putvalue_src3. It also takes in a 32 bit instruction as input which is marked
  as mav_putvalue_instr .
  The following values were assigned to the inputs of the DUT to initialize the test case:
  
  ![inputs](https://user-images.githubusercontent.com/109404741/180964492-b59927d3-c0b6-45a1-9d13-3d8841546d48.PNG)
  
  The following assertion statement is used to check wether the DUT output is equal to the expected out for each instruction or not.
  
  ![Assert](https://user-images.githubusercontent.com/109404741/180964970-a59576b8-69f8-485d-a002-9daf55d5a184.PNG)
  
  Here, the expected value is generated by a python code which is error free and gives the correct value for each instruction and is used to compare with the
  values generated by the DUT.
  
  ![error](https://user-images.githubusercontent.com/109404741/180965560-ff371042-49e0-4a35-8e49-49624dff5c4c.PNG)
  
  From the above assertion error we can see that there is an error for the instruction with hexadecimal code 0x401070B3 and the values for which the error
  is occuring are src1 = 0x1 and src2 = 0x0 .
  
 # Verification strategy
  In order to verify the DUT model a python code (model_mkbitmanip,py) was written which immitates the exact and correct behavior of the processor to generate the expected output.
  This expected out is used to write the assertion statement comparing the DUT output with the expected value. 
  Since, there are 3 32 bit inputs names which are the operands so a nested for loop is used to generate the test case which basically checks for all the values of the
  input ranging from 0x0 to 0xffffffff for each and every instruction and produces the DUT output.
  The following python code snippet gives the algorithm used for verification:
  
  ![algorithm](https://user-images.githubusercontent.com/109404741/180967472-229b97b0-2bfd-454c-818a-5ff598c5e762.PNG)
  
  From the above code snippet we can see that nested for loop for each of the 3 32bit inputs is run from 0x0 to 0xffffffff and the instruction used is ANDN1 which
  corresponds to the hexadecimal value of 0x401070B3. These values are used as an argument to the python function names as bitmanip and generated the correct output
  for the values of inputs and the instruction. Later this correct value is used to comapre with the DUT output.
  
 # Bugs found
  After running the above test case one bug was encountered. For the instruction ANDN1 the expected output is 0x3 for the two input values src1 = 0x1 and
  src2 = 0x0. But, the DUT output is equal to 0x1. So, there is an error for the code under the instruction marked as ANDN1 in the verilog file.
  
 # Debug information
   In order to eliminate the bug in the design verilog file, the code written under the instruction ANDN1 or in hexadecimal as 0x401070B3 should be checked and
   corrected.
  
  
  
